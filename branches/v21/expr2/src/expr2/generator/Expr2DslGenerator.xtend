/*
 * generated by Xtext
 */
package expr2.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import expr2.expr2Dsl.Model
import expr2.expr2Dsl.VarDecl
import expr2.expr2Dsl.Formula
import expr2.expr2Dsl.Return
import expr2.expr2Dsl.Assert
import expr2.expr2Dsl.IntType
import expr2.expr2Dsl.FloatType
import expr2.expr2Dsl.BoolType
import expr2.expr2Dsl.StringType
import expr2.expr2Dsl.ArrayType
import expr2.expr2Dsl.Type
import expr2.expr2Dsl.Expr
import expr2.expr2Dsl.Equals
import expr2.expr2Dsl.Plus
import expr2.expr2Dsl.Multi
import expr2.expr2Dsl.ArrayAccess
import expr2.expr2Dsl.NumberLiteral
import expr2.expr2Dsl.StringLiteral
import expr2.expr2Dsl.FunctionDeclaration
import expr2.expr2Dsl.Parameter
import expr2.expr2Dsl.Symbol
import expr2.expr2Dsl.SymbolRef
import expr2.expr2Dsl.Minus

class Expr2DslGenerator implements IGenerator {
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		val m = resource.contents.get(0) as Model
		fsa.generateFile(m.name.toFirstUpper+".java", '''
		
		import org.junit.Test;
		import junit.framework.Assert;
		
		public class «m.name.toFirstUpper()» {
		 
			@Test
			public void runTest() {
				«FOR e: m.elements»
					«e.elementCode»
				«ENDFOR»
			}
			
			«FOR fd: m.functions.filter(typeof(FunctionDeclaration))»
				public static «fd.type.typecode» «fd.name»( «FOR Symbol p: fd.params SEPARATOR ", "»«(p as Parameter).type.typecode» «p.name»«ENDFOR» ) {
					«FOR e: fd.elements»
						«e.elementCode»
					«ENDFOR»
				}
			«ENDFOR»
			
		}
		''')
	}
	
	def dispatch elementCode(VarDecl v) '''
		«v.type.typecode» «v.name» «IF v.init != null» = «v.init.exprcode»«ENDIF»;
	'''
	
	def dispatch elementCode(Formula f) '''
		«f.type.typecode» «f.name» = «f.expr.exprcode»;
	'''
	
	def dispatch elementCode(Return f) '''
		return «f.expr.exprcode»;
	'''
	
	def dispatch elementCode(Assert f) '''
		«IF f.msg != null»
			Assert.assertEquals(«f.msg.exprcode», «f.expected.exprcode», «f.actual.exprcode»);
		«ELSE»
			Assert.assertEquals( «f.expected.exprcode», «f.actual.exprcode»);
		«ENDIF»
	'''
	
	def dispatch String typecode( Type t ) {}
	def dispatch String typecode( IntType t ) {"int"}
	def dispatch String typecode( FloatType t ) {"double"}
	def dispatch String typecode( BoolType t ) {"boolean"}
	def dispatch String typecode( StringType t ) {"String"}
	def dispatch String typecode( ArrayType t ) {t.baseType.typecode+"[]"}

	def dispatch String exprcode( Expr e ) {}
	def dispatch String exprcode( Equals e ) {e.left.exprcode+" == "+e.right.exprcode}
	def dispatch String exprcode( Plus e) {e.left.exprcode+" + "+e.right.exprcode}
	def dispatch String exprcode( Minus e) {e.left.exprcode+" - "+e.right.exprcode}
	def dispatch String exprcode( Multi e) {e.left.exprcode+" * "+e.right.exprcode}
	def dispatch String exprcode( ArrayAccess e) {e.expr.exprcode+"["e.index.exprcode+"]"}
	def dispatch exprcode( NumberLiteral e) {e.value}
	def dispatch exprcode( StringLiteral e) {"\""+e.value+"\""}
	
	def dispatch String exprcode( SymbolRef e) {
		if ( typeof( FunctionDeclaration ).isInstance(e.symbol) ) 
			(e.symbol.eContainer as Model).name.toFirstUpper+"."+e.symbol.name+"("+e.actuals.map(a|a.exprcode).join(", ")+")"
		else e.symbol.name
	}
	
	
}
